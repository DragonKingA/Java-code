public class ten {
	public static void main(String[] args){
		int n1 = 0b1010; //二进制：由0和1组成满2进1，以0b或0B开头
		int n2 = 1010;   //十进制
		int n3 = 01010;  //八进制：满8进1,以数字0开头
		int n4 = 0x10101;//十六进制：由0~9及A(10)~F(15)组成，满16进1
		                         //以0x或0X开头，A~F不区分大小写
		System.out.println("n1="+n1);//10
		System.out.println("n2="+n2);//1010
		System.out.println("n3="+n3);//520
		System.out.println("n4="+n4);//65793
        
        //位运算---------------------------------以下均以32位运算举例：

		//1.按位与 &：两位全为1，该位结果才为1，否则为0

		//   2的补码为00000000 00000000 00000000 00000010[补]
		//   3的补码为00000000 00000000 00000000 00000011[补]
		//按位与运算后00000000 00000000 00000000 00000010[补]
		//再将结果补码转化为原码（两者恰相等），就能得到2
		System.out.println(2&3);//2
        

        //2.取反 ~：0变1，1变0

        //  -2的原码为10000000 00000000 00000000 00000010[原]
        //  -2的反码为11111111 11111111 11111111 11111101[反]
        //  -2的补码为11111111 11111111 11111111 11111110[补]
        //取反后补码为00000000 00000000 00000000 00000001[补]也即原码
		System.out.println(~-2);//1
        //   2的补码00000000 00000000 00000000 00000010[补]
        //结果补码为11111111 11111111 11111111 11111101[补]
        //结果反码为11111111 11111111 11111111 11111100[反]
        //结果原码为10000000 00000000 00000000 00000011[原]
		System.out.println(~2);//-3


		//3.按位或 |：两位有一个为1，该为结果就为1，否则为0

		//   2的补码为00000000 00000000 00000000 00000010[补]
		//   3的补码为00000000 00000000 00000000 00000011[补]
		//  结果补码为00000000 00000000 00000000 00000011[补]也即原码  
		System.out.println(2|3);//3


		//4.按位异或 ^：异则1，同则0 （异1同0）

		//   2的补码为00000000 00000000 00000000 00000010[补]
		//   3的补码为00000000 00000000 00000000 00000011[补]
		//  结果补码为00000000 00000000 00000000 00000001[补]也即原码
		System.out.println(2^3);//1        
        //小总结：手动计算时要时刻注意正数的三码合一性质，避免多余且错误的计算


        //5.移位操作（右侧操作数为移动位数）

        //*左移<<：高位溢出(符号位也抛出)，低位空位直接补0。--->符号可变

        //故左移会出现正负交换的情况，如21<<27
        //21补码：00000000 00000000 00000000 00010101[补]
        //截到27位00000000 00000000 00000000 000|10101
        //1变成最高位，补0后补码10101000 00000000 00000000 00000000 [补]
        System.out.println("21<<27=" + (21<<27));//-1476395008
        //若是println("21<<27=" + 21<<27)则报错,因为拼接符号+后的21变成String类型
        //使其不能进行移位运算，即移位运算左侧操作数类型发生错误
        
        System.out.println("-2<<3=" + (-2<<3));//-16
        System.out.println("-1476395008<<2="+(-1476395008<<2));//-1610612736
        //-1476395008补码为10101000 00000000 00000000 00000000[补]
        //-1476395008原码为11011000 00000000 00000000 00000000[原]
        //-1610612736补码为10100000 00000000 00000000 00000000[补]
        //可见是由-1476395008的补码运算得来得结果，并且结果也是补码
        //因此移位运算也均是通过 补码 形式进行！！！！！！！！！！！

        System.out.println("-2,013,265,920<<5="+(-2013265920<<5));//
        //-2013265920补码为10001000 00000000 00000000 00000000[补]
        //截到5位后得10001|000 00000000 00000000 00000000
        //补齐0后得到00000000 00000000 00000000 00000000 [补]=> 0
        
        //*右移>>：低位溢出，高位空位补符号位（原数为正数则补0，为负数则补1）--->保证符号不变
    
        System.out.println(3<<1);//6
        System.out.println(3<<33);//6
        System.out.println(3>>1);//1.5==>输出1
        System.out.println(3>>33);//1.5==>输出1
        //注意：如果移动的位数超过了该类型的最大位数，那么编译器会对 移动的位数 取模（取余，除数为32）。
        //如对int型数据向左或向右移动33位，实际上只移动了33%32=1位
        //System.out.println(2.5<<1)或(2<<1.5)均报错，因为两边操作数均为int类型
        //若为byte,short类型，则会自动转换为int类型
        
        //*无符号右移>>>：低位溢出，高位空位直接补0 --->最终结果恒为 非负数

        System.out.println("-2>>>29=" + (-2>>>29));
        //无符号右移操作后：00000000 00000000 00000000 00000111[补]也即原码


		/**计算机运算相关：
		 * 一.有符号数 和 无符号数。
		 * 
		 *  *无符号数 指整个 机器字长 的全部二进制均表示 数值位（最高位不再表示正负）
		 *   -机器字长 是指计算机进行 一次整数运算 所能处理的二进制数据的位数
		 *   -如32位系统指该系统兼容32位CPU，而该CPU一次运算能处理4个字节
		 *   -java只有“有符号数”，而如C语言有“无符号数”
		 *   -32位的无符号数取值0 ~ 2^32 - 1 (0~4294967295)
		 *   -32位的有符号数取值-2^31 ~ 2^31 - 1 (-2147483648~2147483647)
		 * 
		 *  *真值：将带符号位的机器数对应的真正数值 称为机器数的真值 即最高位用±表示数字的正负
		 *   -如 0000 0001的真值= +000 0001 ，1000 0001的真值= –000 0001
		 * 
		 * 
		 * 二.原码，反码，补码。
		 * 
		 *  *非负数（正数及0）的原码、反码、补码相同（三码合一）
		 *   -因为这三码制定的目的是解决关于负数的运算，即可以与非负数统一运算，提高效率
		 * 
		 *  *原码：就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值
		 *   -是用于人脑最容易理解和计算的表示方式
		 *   -理论上8位二进制数的取值范围是[1111 1111 , 0111 1111]即[-127 , 127]
		 *  
		 *  *反码：负数的反码是在其原码的基础上, 符号位不变，其余各个位 取反
		 *   -如[-1] = [10000001]原 = [11111110]反
		 *   -通常人来计算时需转换成原码
		 *   -例：1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
		 *   -观察例子，反码计算减法时结果的真值部分是正确的，而唯一的问题就是“0”这个数
		 *   -虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的
		 *   -而且会导致有[0000 0000]原和[1000 0000]原两个编码表示0
		 *   -补码的出现解决了上述问题（统一了0的编码表示）：
		 *   -1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原=0
		 *   -而多出来的[1000 0000]补用来表示-128，但是注意因为实际上是使用以前的-0的补码来表示-128,
		 *   -所以-128并没有原码和反码表示(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)
		 *   -故8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]，扩大了运算范围
		 * 
		 *  *补码：负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后加 1
		 *   -即在反码的基础上+1  因此 补码 = 反码 + 1 （反码 = 补码 - 1）
		 *   -通常人来计算时也需转换成原码
		 *   -重点：计算机运算(包括移位)时只会以补码的方式来运算！！！！！！！！！！！！！！！！
		 *   -     并且 计算器 输出/输入的二进制也均是 补码！
		 * //https://blog.csdn.net/lqy971966/article/details/106033332?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165882591716782350889615%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165882591716782350889615&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-106033332-null-null.142^v34^new_blog_pos_by_title,185^v2^control&utm_term=%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0&spm=1018.2226.3001.4187
		 * //https://blog.csdn.net/zl10086111/article/details/80907428?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165883892216781647592612%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165883892216781647592612&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80907428-null-null.142^v34^new_blog_pos_by_title,185^v2^control&utm_term=%E8%A1%A5%E7%A0%81&spm=1018.2226.3001.4187

         */


         // 三.计算机中的带符号数用补码表示的优点： 

         // 1、负数的补码与对应正数的补码之间的转换可以用同一种方法——求补运算完成，可以简化硬件； 
         // 2、可将减法变为加法，省去减法器； 
         // 3、无符号数及带符号数的加法运算可以用同一电路完成

         // 详细地说，计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 
         // 于是人们想出了将符号位也参与运算的方法. 我们知道,
         // 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 
         // 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单。
         // 实际上，机器的加减乘除（包括以此衍生的高级运算）均用的是加法器，即机器只需要运算加法，效率高

		
	}
}